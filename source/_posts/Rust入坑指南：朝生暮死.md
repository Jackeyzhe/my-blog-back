---
title: Rust入坑指南：朝生暮死
date: 2020-03-02 23:17:41
tags: Rust
---

今天想和大家一起把我们之前挖的坑再刨深一些。在Java中，一个对象能存活多久全靠JVM来决定，程序员并不需要去关心对象的生命周期，但是在Rust中就大不相同，一个对象从生到死我们都需要掌握的很清楚。<!-- more -->

在[Rust入坑指南：核心概念](https://jackeyzhe.github.io/2019/10/13/Rust%E5%85%A5%E5%9D%91%E6%8C%87%E5%8D%97%EF%BC%9A%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/)一文中我们介绍了Rust的几个核心概念：所有权（Ownership）、所有权转移和所有权借用。今天就来介绍Rust中的另外一个核心概念：生命周期。

为什么生命周期要单独介绍呢？因为我在这之前一直没搞清楚Rust中的生命周期参数究竟是怎么一回事。

现在我终于弄明白了，于是迫不及待要和大家分享，当然如果我有什么说的不对的地方请帮忙指正。

在Rust中，值的生命周期与作用域有关，这里你可以结合所有权一起理解。在一个函数内，Rust中值的所有权的范围即为其生命周期。Rust通过借用检查器对值的生命周期进行检查，其目的是为了避免出现悬垂指针。这点很容易理解，我们通过一段简单的代码来看一下。

``` rust
fn main() {
    let a;  // 'a ---------------+
    {                   //       |
        let b = 1; // 'b ----+   |
        a = &b;           // |   |
    }// ---------------------+   |
    println!("a: {}", a); //     |
} // ----------------------------+
```

在上面这段代码中，我已经标注了a和b的生命周期。在代码的第5行，b将所有权出借给了a，而在第7行我们想使用a时，b的生命周期已经结束，也就是说，从第7行开始，a成为了一个悬垂指针。因此这段代码会报一个编译错误。

![生命周期编译错误](https://res.cloudinary.com/dxydgihag/image/upload/v1582994323/Blog/rust/10/rust10-1.png)

而当所有权在函数之间传递时，Rust的借用检查器就没有办法来确定值的生命周期了。这个时候我们就需要借助生命周期参数来帮助Rust的借用检查器来进行生命周期的检查。生命周期参数分为显式的和隐式的两种。

### 显式生命周期参数

显式生命周期的标注方式通常是`'a`这样的。它应该写在`&`之后，`mut`之前（如果有）。

#### 函数签名中的生命周期参数

在正式开始学习之前，我们还要先明确一些概念。下面是一个代有生命周期参数的函数签名。

``` rust
fn foo <'a>(s: &'a str, t: &'a str) ->&'a str;
```

其中第一个`'a`，是生命周期参数的声明。参数的生命周期叫做输入声明周期，返回值的生命周期叫做输出生命周期。需要记住的一点是：**输出的生命周期长度不能长于输入的生命周期**。

另外还要注意：**禁止在没有任何输入参数的情况下返回引用**。因为这样明显会造成悬垂指针。试想当你没有任何输入参数时返回了引用，那么引用本身的值在函数返回时必然会被析构，返回的引用也就成了悬垂指针。

同样的道理我们可以得出另一个结论：**从函数中返回一个引用，其生命周期参数必须与函数的参数相匹配，否则，标注生命周期参数也毫无意义**。

说了这么多“不允许”之后，我们来看一个正常使用生命周期参数的例子吧。

``` rust
fn the_longest<'a> (s1: &'a str, s2: &'a str) -> &'a str {
    if s1.len() > s2.len() {
        s1
    } else {
        s2
    }
}
fn main() {
    let s1 = String::from("Rust");
    let s1_r = &s1;
    {
        let s2 = String::from("C");
        let res = the_longest(s1_r, &s2);
        println!("{} is the longest", res);
    }
}
```

我们来看看这段代码的各个值的生命周期是否符合我们前面说的那一点原则。在调用th_longest函数时，两个参数的生命周期已经确定，s1的生命周期贯穿了main函数，s2的生命周期在内部的代码块中。函数返回时，将返回值绑定给了res，也就是说返回的生命周期为res的生命周期，由于后定义先析构的原则，res的生命周期是短于s2的生命周期的，当然也短于s1的生命周期。因此这个例子符合了我们说的**输出的生命周期长度不能长于输入的生命周期**的原则。

对于像示例当中有多个参数的函数，我们也可以为其标注不同的生命周期参数，但是编译器无法确定两个生命周期参数的大小，因此需要我们显式的指定。

``` rust
fn the_longest<'a, 'b: 'a> (s1: &'a str, s2: &'b str) -> &'a str {
    if s1.len() > s2.len() {
        s1
    } else {
        s2
    }
}
```

这里`'b: 'a`的意思是`'b`的存活周期长于`'a`。这点有些令人疑惑，`'a`明明是长于`'b`的，为什么会这样标注呢？还记得我们说过生命周期参数的意义吗？它是用来帮助Rust借用检查器来检查非法借用的，输出生命周期必须短于输入生命周期。因此这里的`'a`实际上是返回值的生命周期，而不是第一个输入参数的生命周期。

函数中的生命周期参数的使用我们暂时先介绍到这里。生命周期在其他使用场景中的使用方法也比较类似，不过还是有一些值得注意的地方的。

#### 结构体中的生命周期参数

如果一个结构体包含引用类型的成员，那么结构体应该声明生命周期参数`<'a>`。这是为了保证**结构体实例的生命周期应该短于或等于任意一个成员的生命周期**。

``` rust
struct ImportantExcept<'a> {
    part: &'a str,
}

fn main() {
    let novel = String::from("call me Ishmael. Some year ago...");
    let first_sentence = novel.split('.')
        .next()
        .expect("Could not find a '.'");
    let i = ImportantExcept { part: first_sentence};
    assert_eq!(i.part, "call me Ishmael");
}
```

在这段代码中`first_sentence`先于结构体实例`i`被定义，因此`i`的生命周期是短于`first_sentence`的，如果反过来，`i`的生命周期长于`first_sentence`即长于`part`，那么在`part`被析构以后，`i.part`就会成为悬垂指针。

#### 方法中的生命周期参数

现在我们为刚才的结构体增加一个实现方法

``` rust
impl<'a> ImportantExcept<'a> {
    fn get_first_sentence(s: &'a str) -> &'a str {
        let first_sentence = s.split('.')
            .next()
            .expect("Could not find a '.'");
        first_sentence
    }
}
```

因为`ImportantExcept`包含引用成员，因此需要标注生命周期参数。在`impl`后面声明生命周期参数`<'a>`在结构体名称后面使用。在`get_first_sentence`方法中使用的生命周期参数也是刚刚定义好的那个。这样就可以约束输入引用的生命周期长度长于结构体实例的生命周期长度。

#### 静态生命周期参数

前面聊的都是我们自己定义的生命周期参数，现在来聊聊Rust中内置的生命周期参数`'static`。`'static`生命周期存活于整个程序运行期间。所有的字符串字面量都有`'static`生命周期，类型为`&'static str`。

### 隐式生命周期参数

在某些情况下，我们可以省略生命周期参数，对于省略的生命周期参数通常有三条规则：

- 每个输入位置上省略的生命周期都将成为一个不同的生命周期参数
- 如果只有一个输入生命周期的位置，则该生命周期将分配给输出生命周期
- 如果存在多个输入生命周期的位置，但是其中包含&self或&mut self，则self的生命周期将分配给输出生命周期

### 生命周期限定

生命周期参数也可以像trait那样作为范型的限定

- T: 'a：表示T类型中的任何引用都要“活得”和'a一样长
- T：Trait + 'a：表示T类型必须实现Trait这个trait，并且T类型中的任何引用都要“活得”和'a一样长

### 总结

现在我把我对Rust生命周期的了解都分享完了。其实只要记住一个原则就可以了，那就是：**生命周期参数的目的是帮助借用检查器验证引用的合法性，避免出现悬垂指针**。

Rust还有几个深坑，我们下次继续。